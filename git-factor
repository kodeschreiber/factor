#!/bin/bash

exec 3>&1 4>&2 5>&1
GIT_ROOT="$(git rev-parse --show-toplevel)"
FACTOR_FILE="$(realpath "${FACTOR_FILE:-${GIT_ROOT}/factor.conf}")"
HERE="$(dirname "${FACTOR_FILE}")"
FACTDIR="${HERE}/.factor"
RFACTDIR="$(echo "${FACTDIR}" | sed 's/.*\(\.factor\.*\)/\1/')"
OPER="${1}"

# _msg <type> <info>
_msg() {
  RED='\033[0;31m'
  BLUE='\033[1;34m'
  NC='\033[0m' # No Color
  lvl="$(_config 'factor.verbose')"
  lvl="${lvl:-1}"
  case "${1}" in
    ACTION)
      if [ $lvl -ge 1 ]; then echo -e "- ${2}" >&3; fi
    ;;
    ERROR)
      if [ $lvl -ge 1 ]; then echo -e "${RED}! ${2}${NC}" >&4; exit 10; fi
    ;;
    DEBUG)
      if [ $lvl -ge 2 ]; then echo -e "${BLUE}? ${2}${NC}" >&5; fi
    ;;
  esac
}

### Aliases ###
@a() {
  _msg ACTION "${1}"
}

@e() {
  _msg ERROR "${1}"
}

@d() {
  _msg DEBUG "${1}"
}

# error if no zero
@einz() {
  if [ $? -ne 0 ]; then @e "${1}"; fi
}
###############

_def_config() {
  mkdir -p "${FACTDIR}"
  cat <<EOF >"${FACTDIR}/config"
[factor]
  saveenv = true
  verbose = 1
  prefix = %git%
  env = %none%
EOF
}

# _get_vars <resource>
_get_vars() {
  @d "Getting settings for resource '${1}'"
  cat "${FACTOR_FILE}" | \
  sed -n "/\[${1}\]/,/^\s*\[*[a-zA-Z0-9_-]*\]*$/"'!d'"; //d; /^\s*#/d; s/^\s*\([a-zA-Z][a-zA-Z0-9]*=.*\)/\1/; s@%git%@${GIT_ROOT}@; p"
}

# _rem_vars <resource> <file>
_rem_vars() {
  @d "Removing section for resource '${1}'"
  sed -i "/\[${1}\]/,/^\s*\[*[a-zA-Z0-9_-]*\]*$/{/\[${1}\]/d;/^\s*\[*[a-zA-Z0-9_-]*\]*$/"'!d'"}" "${2}"
  @einz "Failed to prune resource '${1}' from factor.conf"
}

_sync_cache_to_build() {
  @d "Creating prefix directory for '${1}'"
  mkdir -p "${f_prefix}"
  @d "Copying cache to prefix for '${1}'"
  rsync -a "${f_cache}/" "${f_prefix}/"
}

_usage() {
  @d "Printing usage information"
  cat <<'EOF'
%doc%
EOF
}

# _get_resource <resource>
_get_resource() {
  @d "Sourcing variables for '${1}'"
  source <(_get_vars "${1}" | sed 's/\(.*\)/f_\1/' | sed "s/=\"/='/;s/\"\s*\$/'/" | sed "s/=/='/;s/\$/'/")
  
  @d "Checking for required variables for '${1}'"
  if [ -z "${f_env}" ]; then f_env="$(_config 'factor.env' | sed 's/%none%//g')"; fi
  f_prefix="${f_prefix:-$(_config 'factor.prefix' | sed "s@%git%@${GIT_ROOT}@")}"
  if [ -z "${f_url}" ]; then @e "No url defined for ${1}"; fi
  if [ -z "${f_prefix}" ]; then @e "No prefix provided for ${1}"; fi
  if [ -z "${f_script}" ]; then
    ffiles="$(find "${HERE}" | grep "/${1}.factor" | wc -l)"
    if [ $ffiles -lt 1 ]; then
      @e "No script defined or ${1}.factor files located in GIT root"
    elif [ $ffiles -gt 1 ]; then
      @e "Multiple ${1}.factor files located. Please define the one you wish to use."
    fi
    f_script="$(find "${HERE}" | grep "${1}.factor")"
  fi
  f_quote="'"
  if [ "$(_config 'factor.safeenv')" == "false" ]; then
    f_quote='"'
  fi
  
  @d "Setting common variables for '${1}'"
  f_tag="${f_tag:-master}"
  f_moddir="${FACTDIR}/${1}"
  f_lock="${f_moddir}/lock"
  f_cache="${f_moddir}/cache"
  f_module="${f_moddir}/module"
  f_rmodule="${RFACTDIR}/${1}/module"
  f_tagfile="${f_moddir}/tag"
  f_tmp_root="${f_cache}/.root_bind"
  f_tmp_module="${f_cache}/.module_bind"
}

_global_sync() {
  @d "Ensuring .factor directory"
  mkdir -p "${FACTDIR}"
  @d "Adding .gitignore file"
  echo "." > "${FACTDIR}/.gitignore"
  
  @d "Ensuring saveenv variable"
  if [ -z "$(_config 'factor.safeenv')" ]; then
    _config 'factor.safeenv' true
  fi
  
  @d "Ensuring verbose variable"
  if [ -z "$(_config 'factor.verbose')" ]; then
    _config 'factor.verbose' 1
  fi
  
  @d "Ensuring prefix variable"
  if [ -z "$(_config 'factor.prefix')" ]; then
    _config 'factor.prefix' '%git%'
  fi
  
  @d "Ensuring env variable"
  if [ -z "$(_config 'factor.env')" ]; then
    _config 'factor.env' '%none%'
  fi
}

# _sync <resource>
_sync() {
  @a "Synchronizing '${1}'"
  @d "Checking for factor.conf"
  if [ ! -f "${FACTOR_FILE}" ]; then
    echo "DEBUG: ${FACTOR_FILE}"
    @e "Could not find a factor.conf file in this repository"
  fi
  
  @d "Performing global sync for '${1}'"
  _global_sync
  _get_resource "${1}"
  
  @d "Ensuring module, lock and tag for '${1}'"
  if [ ! -d "${f_moddir}" ]; then mkdir -p "${f_moddir}"; fi
  if [ ! -f "${f_lock}" ]; then touch "${f_lock}"; fi
  if [ ! -f "${f_tag}" ]; then touch "${f_tagfile}"; fi
  
  @d "Check if '${1}' need to be indexed"
  if ! grep -qs "\[submodule \"${1}\"\]" "${HERE}/.gitmodules"; then
    git submodule add --force --name "${1}" "${f_url}" "${f_rmodule}"
  fi
  
  @d "Updating the url and tag of '${1}'"
  git config -f "${HERE}/.gitmodules" "submodule.${1}.branch" "${f_tag}"
  git config -f "${HERE}/.gitmodules" "submodule.${1}.url" "${f_url}"
  
  @d "Updating '${1}' if its module directory is empty"
  if [ "$(find "${f_rmodule}" -maxdepth 0 -empty)" == "${f_rmodule}" ]; then
    git submodule update --init --force "${f_module}"
  else
    git submodule update --force "${f_module}"
  fi
}

# _build <resource>
_build() {
  @d "Syncing '${1}'"
  $0 sync "${1}" 2>&1 >/dev/null
  @einz "Cannot build ${1}"
  _get_resource "${1}"

  @d "Getting the varibles for checking"
  curr_hash="$(md5sum "${f_script}" | head -c32)"
  lock_hash="$(cat "${f_lock}")"
  lock_tag="$(cat "${f_tagfile}")"
  
  @d "Checking '${1}'s dependencies"
  deprebuilt=0
  while read req; do
    if [ -z "${req}" ]; then continue; fi
    $0 build "${req}"
    case $? in
      12) continue; ;;
      11) deprebuilt=1; ;;
      *) @e "Requirement '${req}' for resource '${1}' failed to build"; ;;
    esac
  done < <(echo "${f_requires}" | sed 's/ /\n/g')
  
  @d "Checking if rebuilding '${1}' is necessary"
  if [ $deprebuilt -ne 1 -a -d "${f_cache}" -a \
    "${curr_hash}" == "${lock_hash}" -a "${f_tag}" == "${lock_tag}" ]; then
    @d "Rebuild not required for '${1}'"
    _sync_cache_to_build
    exit 12
  fi

  @a "Building '${1}'"
  @d "Fetching and setting the tag for '${1}'"
  (
    cd "${f_module}"
    git fetch --all 
    git checkout "${f_tag}"
  )
  
  @d "Renewing cache for '${1}'"
  if [ -d "${f_cache}" ]; then rm -rf "${f_cache}"; fi
  if [ ! -d "${f_cache}" ]; then mkdir -p "${f_cache}"; fi
  (
    cd "${f_module}"
    
    @d "Ensure that we are in '${1}' and not hte parent"
    if [ "${GIT_ROOT}" == "$(git rev-parse --show-toplevel)" ]; then
      @e "Refusing to build; target git directory is the parent not the submodule: '${1}'"
    fi
    
    @d "Resetting module"
    git reset --hard
    git clean -xfdf

    @d "Creating environment for '${1}'"
    export PREFIX_CACHE="${f_cache}"
    export PREFIX_BUILD="${f_prefix}"
    export GIT_ROOT="${git rev-parse --show-toplevel}"
    while read envi; do
      source <(_get_vars "${envi}" | sed 's/\(.*\)/export \1/' | sed "s/=\"/='/;s/\"\s*\$/'/" | sed "s/=/=${f_quote}/;s/\$/${f_quote}/")
    done < <(echo "${f_env}" | sed 's/ /\n/g')
    @d "Executing script for '${1}'"
    env -C "${f_module}" "${f_script}"
  )
  
  @einz "Failed to build package ${1}"

  @d "Updaing the lock and tag"
  _sync_cache_to_build
  echo "${curr_hash}" > "${f_lock}"
  echo "${f_tag}" > "${f_tagfile}"
  return 11
}

_clean() {
  @a "Cleaning '${1}'"
  _get_resource "${1}"
  rm -rf "${f_moddir}"
}

# _config <key> <val>
_config() {
  git config -f "${FACTDIR}/config" "${1}" "${2}"
}

# _prune <resource>
# There could be potentially a better way using the name "${1}"
# as opposed to the modules path at "${f_module}"
_prune() {
  @a "Pruning '${1}'"
  _get_resource "${1}"
  @d "Deinit for '${1}'"
  git submodule deinit -f "${f_module}"
  @d "Removing from index for '${1}'"
  git rm -f "${f_module}"
  _rem_vars "submodule \"${1}\"" "${HERE}/.gitmodules"
  @d "Rebuilding index"
  git add "${HERE}/.gitmodules"
  @d "Removing any cache in index for '${1}'"
  git rm --cached "${f_module}"
  @d "Commiting changes"
  git commit -m "Removed submodule ${1}"
  @d "Removing actual cache for '${1}'"
  rm -rf "${HERE}/.git/modules/${1}"
  @d "Removing .factor directory for '${1}'"
  rm -rf "${f_module}"
  @d "Indexing"
  git add .
  @d "Clean for '${1}'"
  $0 clean "${1}"
  _rem_vars "${1}" "${FACTOR_FILE}"
}

if [ ! -f "${FACTDIR}/config" ]; then
  _def_config
fi

if [ $# -lt 2 ]; then
  _usage
  @e "Too few arguments"
fi

shift
while [ $# -gt 0 ]; do
  case "${OPER}" in
    sync) _sync "${1}"; ;;
    build) _build "${1}"; exit $?; ;;
    clean) _clean "${1}"; ;;
    prune) _prune "${1}"; ;;
    config) _config "${1}" "${2}"; ;;
    *) _usage; exit 1; ;;
  esac
  shift
done
