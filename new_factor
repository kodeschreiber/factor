#!/bin/bash

set -e
DEBUG="${DEBUG:-}"
TMPDIR="$(mktemp -d)"
CONFIG="${TMPDIR}/config"

# filterpipe <pipepath> <sed_output> <outpipe>
filterpipe() {
  (
    if [ ! -p "${1}" ]; then mkfifo "${1}"; fi
    sed "s/\(.*\)/${2}/" < "${1}" >&$3
  ) &
  while [ ! -p "${1}" ]; do sleep 0.1; done
}

@e() { errmsg="${@}"; }

filterpipe "${TMPDIR}/out" '> \1' 1
filterpipe "${TMPDIR}/err" "$(printf '\033')[0;31m! \1$(printf '\033')[0m" 2

exec 3>&1 4>&2 5>&1
exec 1>"${TMPDIR}/out" 2>"${TMPDIR}/err"

test ! -z $DEBUG && trap 'echo -e "\033[1;34m? ${BASH_COMMAND}\033[0m" >&5' DEBUG
trap 'rm -rf "${TMPDIR}"' EXIT
trap 'echo -e "\033[0;31m! ${errmsg}\033[0m" >&4; exit 10' ERR

### FACTOR CODE ###
GIT_ROOT="$(git rev-parse --show-toplevel)"
FACTDIR="${GIT_ROOT}/.factor"

_usage() {
  cat <<'EOF'
%doc%
EOF
}

# _get_vars <resource>
_get_vars() {
  cat "${CONFIG}" | \
  sed -n "/\[${1}\]/,/^\s*\[*[a-zA-Z0-9_-]*\]*$/"'!d'"; //d; /^\s*#/d; s/^\s*\([a-zA-Z][a-zA-Z0-9]*=.*\)/\1/; s@%git%@${GIT_ROOT}@; p"
}

_compose_config() {
  find "${GIT_ROOT}" -type f -name *.py -exec cat {} + > "${CONFIG}"
  cat <<EOF >>"${CONFIG}"
[default_factor_values]
  tag=master
  prefix=%git%

[endoffactorconfig]
EOF
}

# _compose_entry <entry>
_compose_entry() {
  _get_vars "${1}" | \
  sed 's/\(.*\)/f_\1/' | \
  sed "s/=\"/='/;s/\"\s*\$/'/" | \
  sed "s/=/='/;s/\$/'/"
}

# _compose_script scr1 ... scrN
_compose_script() {
  for scr in $@; do
    _get_vars "${scr}"
  done > "${f_tmp_script}"
  chmod +x "${f_tmp_script}"
}

# _compose_environment env1 ... envN
_compose_environment() {
  for envi in $@; do
    _get_vars "${envi}"
  done | sed 's/\(.*\)/export \1/' | \
         sed "s/=\"/='/;s/\"\s*\$/'/"
  cat <<EOF
export PREFIX_CACHE="${f_cache}"
export PREFIX_BUILD="${f_prefix}"
export GIT_ROOT
EOF
}

# _get_resource <resource>
_get_resource() {
  source <(_compose_entry "default_factor_values")
  source <(_compose_entry "factor")
  source <(_compose_entry "${1}")
  
  @e "No url defined for ${1}"
  test ! -z "${f_url}"
  @e "No prefix provided for ${1}"
  test ! -z "${f_prefix}"
  
  f_moddir="${FACTDIR}/${1}"
  f_lock="${f_moddir}/lock"
  f_cache="${f_moddir}/cache"
  f_module="${f_moddir}/module"
  f_tagfile="${f_moddir}/tag"
  f_rmodule="${RFACTDIR}/${1}/module"
  f_tmp_script="${TMPDIR}/${1}.sh"
}

# _build <resource>
_build() {
  if [ ! -d "${f_moddir}" ]; then mkdir -p "${f_moddir}"; fi
  if [ ! -f "${f_lock}" ]; then touch "${f_lock}"; fi
  if [ ! -f "${f_tag}" ]; then touch "${f_tagfile}"; fi
  
  @e "Could not pull the module ${1}"
  if [ ! -d "${f_module}" ]; then
    git clone "${f_url}" -b "${f_tag}" "${f_module}"
  fi

  curr_hash="$(md5sum "${f_script}" | head -c32)"
  lock_hash="$(cat "${f_lock}")"
  lock_tag="$(cat "${f_tagfile}")"
  
  deprebuilt=0
  while read req; do
    if [ -z "${req}" ]; then continue; fi
    $0 build "${req}"
    @e "Requirement '${req}' for resource '${1}' failed to build";
    case $? in
      12) continue; ;;
      11) deprebuilt=1; ;;
      *) /bin/false; ;;
    esac
  done < <(echo "${f_requires}" | sed 's/ /\n/g')
  
  if [ $deprebuilt -ne 1 -a -d "${f_cache}" -a \
    "${curr_hash}" == "${lock_hash}" -a "${f_tag}" == "${lock_tag}" ]; then
    mkdir -p "${f_prefix}"
    rsync -a "${f_cache}/" "${f_prefix}/"
    exit 12
  fi

  (
    cd "${f_module}"
    git fetch --all
    git checkout "${f_tag}"
  )
  
  rm -rf "${f_cache}"
  mkdir -p "${f_cache}"
  
  pushd "${f_module}"

  @e "Refusing to build; target git directory is the parent not the submodule: '${1}'"
  test "${GIT_ROOT}" == "$(git rev-parse --show-toplevel)"

  git reset --hard "${f_tag}"
  git clean -xfdf

  @e "Failed to build package ${1}"
  _compose_script
  env -C "${f_module}" $(_compose_environment | xargs) "${f_script}"

  mkdir -p "${f_prefix}"
  rsync -a "${f_cache}/" "${f_prefix}/"
  echo "${curr_hash}" > "${f_lock}"
  echo "${f_tag}" > "${f_tagfile}"
  return 11
}

mkdir -p "${FACTDIR}"
if ! grep '^.factor' "${GIT_ROOT}/.gitignore"; then
  echo ".factor" >> "${GIT_ROOT}/.gitignore"
fi

_compose_config

if [ $# -lt 2 ]; then
  _usage
  @e "Too few arguments"
fi

shift
while [ $# -gt 0 ]; do
  _get_resource "${1}"
  case "${OPER}" in
    build) _build "${1}"; exit $?; ;;
    clean) rm -rf "${f_moddir}"; ;;
    *) _usage; exit 1; ;;
  esac
  shift
done
